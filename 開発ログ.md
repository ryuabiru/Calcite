# プロジェクト「Calcite」開発ログ (2025/08/25更新)

## 1. このプロジェクトで実装したいこと

- **直感的な操作性**: `Mito`や`GraphPad Prism`のように、プログラミング知識がなくてもGUI操作だけでデータハンドリング、統計解析、グラフ作成が完結するアプリケーションを目指す。
- **統合環境**: データのインポート、表計算、統計解析、グラフ描画、結果のエクスポートといった一連のワークフローを、シームレスに一つのウィンドウで提供する。
- **論文品質のグラフ**: ユーザーがタイトル、ラベル、色、エラーバーなどを自由に編集でき、学術論文やプレゼンテーションにそのまま利用できる高品質なグラフを作成できる機能。

---

## 2. これまでに実装してきたこと

- **基本UI/UXの改善**
  - **レイアウト変更**: プロパティパネルを画面下部に配置し、データテーブルとグラフの表示領域を拡大。**メインウィンドウを上下分割する`QSplitter`を導入し、起動時のプロパティパネルの高さを最適化**しました。
  - **タブUIの導入**: プロパティパネルを「データ」「フォーマット」「テキスト」「軸」のタブに分割し、設定項目を整理してアクセス性を向上。
  - **高DPI対応**: アプリケーション全体で高解像度ディスプレイをサポートし、グラフやフォントが鮮明に表示されるように改善。

- **データハンドリング機能**
  - **CSVファイルのインポート**: メニューバーからCSVを読み込み、`Pandas`データフレームとして内部で保持。
  - **クリップボードからのペースト**: Excelなどからコピーしたタブ区切りデータをアプリケーションに直接貼り付ける機能を追加 (`Edit` > `Paste`)。
  - **テーブル表示とインタラクティブ編集**:
    - `QTableView`を用いたスプレッドシート形式での表示、セルやカラムヘッダーの直接編集機能。
    - 右クリックメニューからの行・列の追加、削除機能。
  - **データ変換**:
    - **ワイドからロングへ (`melt`)**: `pandas.melt`を基盤としたGUIツールで、データをTidy Data形式に再構成する機能。
    - **ロングからワイドへ (`pivot`)**: `pandas.pivot_table`を基盤とし、Tidy Dataをクロス集計されたワイド形式に変換する機能を追加。
    - **数式による列作成**: `pandas.eval`を基盤とし、「`'ColumnA' * 100`」のような数式で新しい列を動的に作成する機能。

- **グラフ描画・編集機能**
  - **描画エンジンのSeabornへの統一**: **グラフ描画のコアエンジンを`matplotlib`から`seaborn`へ全面的に移行しました。** これにより、デフォルトでより美しく、学術論文に適した品質のグラフ（散布図、棒グラフ、ペアード散布図など）を少ないコードで描画できるようになり、アプリケーションの目指す方向に大きく前進しました。
  - **グラフタイプ**: ツールバーから**散布図**、**棒グラフ**（エラーバー、個別データ点の重ね描き対応）、**ペアード散布図**、**箱ひげ図**、**バイオリンプロット**、**ポイントプロット**、**折れ線グラフ**を動的に切り替え可能に。
  - **プロパティパネルによる詳細な編集**:
    - **テキスト**: グラフのタイトル、X/Y軸ラベル、目盛りの**フォントサイズ**を個別に設定可能に。
    - **軸**: X/Y軸の**表示範囲 (Min/Max)** の手動設定、および**対数スケール (Log Scale)** への切り替え機能を追加。グリッド線の表示/非表示も可能に。
    - **フォーマット**: マーカーの種類や色、枠線の色・太さなどを設定可能に。
    - **Prism風スタイル**: グラフの**上と右の枠線（Spine）を非表示にするオプション**を追加。

- **統計解析とアノテーション機能**
  - **統計アノテーション機能の刷新**: **自前で実装していたアノテーション描画ロジックを廃止し、専門ライブラリ`statannotations`を導入しました。** これにより、t検定やANOVAのp値を元にしたアスタリスク付きブラケットの描画が、**重なりを自動回避しながら堅牢に**行われるようになり、コードの保守性と安定性が劇的に向上しました。
  - **対応のあるt検定**: 2つのペアの列を直接比較する検定機能を追加。
  - **一元配置分散分析 (ANOVA)**: 3群以上の比較に対応。
  - **カイ二乗検定**: `pd.crosstab`を利用し、2つのカテゴリカル変数間の関連を検定する機能を追加。
  - **線形・非線形回帰分析**: 散布図にフィットラインを描画し、凡例に**R²値**を表示。シグモイド曲線（4パラメータロジスティックモデル）のフィッティングにも対応します。

- **エクスポート機能**
  - 作成したグラフを**PNG, JPEG, SVG, PDF**形式で、300 DPIの高解像度で保存する機能を追加 (`File` > `Save Graph As...`)。

---

## 3. 設計思想のブレークスルーとアーキテクチャの刷新 (2025/08/25)

- **課題の再認識と「グラフファースト」への転換**: 従来の開発過程で、アノテーション機能の実装において根深い問題が明らかになった。それは、**統計検定の実行（`action_handler`）とアノテーションの描画（`graph_manager`）の間で、どのグループペアを比較したかの情報（コンテキスト）が不一致になりやすい**という問題である。特に、サブグループ（hue）やファセットを使った複雑なグラフに対する検定では、`statannotations`ライブラリが要求するペアの形式が動的に変わるため、エラーが頻発し、実装が非常に複雑化していた。

- **新アーキテクチャ：「生成→検定→翻訳」モデルの確立**: この問題を根本的に解決するため、「グラフファースト」の思想をさらに推し進め、すべての統計解析を以下の3ステップで行う、新しい堅牢なアーキテクチャを確立した。
  1. **【生成】検定用グループの生成**:
     - 統計解析が実行されると、まず現在のグラフ設定（X軸、サブグループ）を確認する。
     - サブグループが指定されている場合、`X軸`と`サブグループ`の値を、衝突しないユニークな区切り文字（例: `_#%%%_`）で結合した**内部的な「交互作用グループ」**を動的に生成する。
     - これにより、どんなに複雑なデータ構造も、**必ず一次元のシンプルなグループリスト**として正規化される。
  2. **【検定】統計エンジンの実行**:
     - 正規化された一次元グループを元に、統計検定（ANOVA, t検定など）を実行する。
     - 統計エンジンはデータの由来を気にする必要がなく、常にシンプルな文字列ペアに対するp値を計算することに集中できる。
  3. **【翻訳】アノテーション形式への変換**:
     - 検定結果のシンプルな文字列ペアを、**「翻訳層」** が受け取る。
     - この翻訳層は、現在のグラフ描画コンテキスト（サブグループが使われているか）だけを元に、`statannotations`ライブラリが要求する厳密な形式（例: `(('A', 'c'), ('B', 'd'))`のようなタプルのタプル）へと機械的に変換する。

- **ファセット機能への対応とアーキテクチャの完成**: 上記モデルをさらに拡張し、ファセット化されたグラフにも対応した。
  - **コンテキストの拡張**: `action_handler`は、ファセットの各カテゴリに対してループ処理で検定を行い、生成されるアノテーション辞書に**どのファセットに属するか (`facet_value`)**という情報を記録する。
  - **描画マネージャーの知能化**: `graph_manager`は、各サブプロットを描画する際に、そのサブプロットに対応する`facet_value`を持つアノテーションのみをフィルタリングして描画する。
  - **UIと意図の同期**: ユーザーが`X-Axis`と`Sub-group`に同じ列を指定した場合、「分析ではなく色分けが目的」であるとプログラムが賢く判断し、分析ロジック上はサブグループを無視するが、描画上の色分けは維持する、という直感的な挙動を実現した。
  - この一連の改修により、`KeyError`, `AttributeError`, `ValueError`といった根深いバグを解消し、あらゆるデータ構造に対して統一的で堅牢な分析とアノテーション描画が可能になった。

---

## 4. 描画アーキテクチャの刷新と「Matplotlib-first」への移行 (2025/08/25)

### 4.1. 課題：`seaborn.catplot`の限界とアーキテクチャの見直し

- **問題の特定**: `boxplot`の上に`stripplot`を重ね描きする際の軸のズレや、ファセット利用時の凡例制御の複雑化など、`seaborn.catplot`という高レベルな関数に描画を任せるアーキテクチャの限界が露呈した。`catplot`は手軽な反面、内部の`Figure`や`Axes`オブジェクトへのアクセスが間接的になり、細かいカスタマイズが困難になるという問題があった。

### 4.2. 解決策：「Matplotlib-first」思想の導入と実装

- **新アーキテクチャの確立**: この問題を根本的に解決するため、描画の役割を明確に分離する「Matplotlib-first」アーキテクチャへ移行した。
  1. **【準備】Matplotlibでキャンバスを準備**: `matplotlib.pyplot.subplots()`を使い、グラフの「舞台」となる`Figure`と`Axes`オブジェクトを明示的に作成する。ファセットが必要な場合は、サブプロットのグリッドとして生成する。
  2. **【描画】Seabornは描画に専念**: `seaborn`の役割を、`ax`引数を通じて、準備されたキャンバス上にグラフを描画することだけに限定する。これにより、`catplot`のブラックボックス化された挙動から解放された。
  3. **【統合】Matplotlibで凡例を完全制御**: `seaborn`による凡例の自動生成は一切行わず、描画完了後に、取得または自作した凡例情報を使って`fig.legend()`で図全体の凡例を統一的に描画する。

### 4.3. 成果

- このアーキテクチャ移行により、当初の課題であった重ね描きや凡例制御の問題が完全に解決された。
- コードの責務が明確化され、今後の機能拡張（新しいグラフタイプの追加など）が容易な、よりクリーンで保守性の高い構造となった。
- 凡例をグラフの枠外右上に配置するスタイルをデフォルトにするなど、論文品質のグラフ作成に向けた機能強化が実現した。

---

## 5. 最近の主な機能追加と改善 (2025/08/25)

- **データハンドリング機能の強化**:
  - **高度なフィルタリング機能の実装**:
    - **動的UIの導入**: 複数のフィルタリング条件を`AND`または`OR`で自由に組み合わせることができる、高度なフィルターダイアログを実装しました。
    - **堅牢な設計**: UIの責務（入力の受付）とデータ処理の責務（`query`文字列への翻訳）を明確に分離する設計を採用。これにより、コードの保守性と拡張性が大幅に向上しました。
    - **データ型に応じた条件分岐**: フィルタリング対象のカラムが**数値か文字列か**を自動で判別し、`>` や `contains` といった利用可能な比較演算子を動的に切り替える、直感的なUIを実現しました。
  - **テーブルデータのソート機能**:
    - テーブルの列ヘッダーを**シングルクリック**することで、データを昇順・降順に並び替えられる機能を実装しました。ダブルクリックによる列名編集機能との競合を回避し、直感的な操作を実現しています。
  - **テーブルデータのエクスポート機能**:
    - `File`メニューに`Save Table As...`を追加。フィルタリングやソートで加工した後のデータを、CSVファイルとして保存できるようになりました。

- **Pythonスクリプトとの連携強化**:
  - **DataFrameの直接入力**: `main.py`をリファクタリングし、`pandas.DataFrame`を直接引数として渡してGUIを起動できるようになりました。これにより、Jupyter Notebookなど既存のPython分析環境から、Calciteをシームレスに呼び出すことが可能になりました。

- **グラフ機能の強化**:
  - **新しいグラフタイプ「折れ線グラフ」の追加**:
    - **連続データへの対応**: 吸光度スペクトルのように、X軸が連続的な数値であるデータの可視化に最適化された「折れ線グラフ (`Line Plot`)」を追加しました。
    - **パフォーマンスと明瞭さ**: 大量のデータポイントも高速に描画し、トレンドやピークの形状を明瞭に表現します。
  - **Paired Scatter Plotの機能強化**:
    - **統計アノテーション**: 対応のあるt検定やウィルコクソン検定の結果を、グラフ上部にブラケットとアスタリスクで描画できるようになりました。
    - **プロパティ適用**: 他のグラフと同様に、マーカー、線、テキスト、凡例の位置など、すべての見た目をプロパティパネルから完全にカスタマイズできるようになりました。

- **UI/UXとバグ修正**:
  - **ファセットの描画順**: ファセット（グラフ分割）利用時に、カテゴリーが意図せずアルファベット順にソートされてしまう問題を修正。データファイルに登場する順番を維持するように改善しました。
  - **UIの一貫性**: Point Plot、Line Plot、回帰直線の「線」のスタイル（線の種類や太さ）を、「フォーマット」タブの共通設定で一括変更できるようにし、操作の一貫性を高めました。
  - **ダイアログのサイズ調整**: ユーザーからのフィードバックに基づき、高度なフィルターダイアログの初期表示サイズを調整し、視認性を向上させました。

---

## 6. これからの実装予定

- **統計解析機能の追加**:
  - **二元配置分散分析（Two-way ANOVA）**など、より高度な統計手法の実装。

- **グラフ編集機能のさらなる強化**:
  - **テキスト・図形追加**: グラフ上の任意の位置にテキストボックスや矢印などを追加・編集する機能。

## 7. 描画アーキテクチャの課題とレイヤー化による堅牢性の確立 (2025/08/27)

### 7.1. 課題：複雑な分岐による保守性の低下と根深いバグ

`summary_scatter`グラフの実装と、それに伴う「個々のデータ点（individual points）の重ね描き」機能の修正過程で、`graph_manager`の描画ロジックが抱える根深い問題が明らかになった。

- **問題の症状**: あるグラフタイプ（例: `summary_scatter`）を修正すると、別のグラフタイプ（例: `bar`）の描画や、重ね描きオプションの挙動に意図せぬ副作用（デグレード）が発生する。特に、サブグループ（`hue`）利用時の描画位置がずれる「**二重dodge問題**」が頻繁に再発した。
- **根本原因**: `draw_categorical_plot`関数内の`if/elif/else`による条件分岐が、**関心事が異なる複数の責務を「入れ子（ネスト）」構造で扱っていた**ことにある。具体的には、「**何を描くか（グラフの種類）**」という責務と、「**どう配置するか（重ね描きの位置調整）**」という責務が密結合していた。これにより、新しいグラフタイプを追加するたびに、すべての分岐に影響がないかを確認する必要があり、メンテナンス性が著しく低下していた。

### 7.2. アーキテクチャの再検討：「宣言的」なレイヤー化設計への移行

この問題を根本的に解決するため、描画ロジックを「手続き的」な実装から、責務を完全に分離した**「宣言的」なレイヤー（層）アーキテクチャ**へと刷新する。

これは、一つの関数がすべての描画手順を細かく指示するのではなく、**「グラフを構成するレイヤー（層）は何か」を宣言**し、各レイヤーが独立して自身の描画責務を果たすという設計思想である。

#### レイヤー化された描画プロセス

1. **データ準備レイヤー**:
   - 責務: 描画に使用するデータを準備する。
   - `summary_scatter`であれば、このレイヤーが**データの要約（平均値・標準誤差の計算）**という前処理を担当する。他のグラフタイプでは、元のデータをそのまま次のレイヤーに渡す。

2. **ベースレイヤー（Base Plot）**:
   - 責務: グラフの主役となる要素（棒、箱、バイオリン、線など）を描画する。
   - `scatter`や`summary_scatter`のように主役が「点」であるグラフの場合、このレイヤーは何もしない。

3. **散布図レイヤー（Scatter Plot）**:
   - 責務: `scatter`または`summary_scatter`（平均点＋エラーバー）を描画する。
   - このレイヤーは、グラフタイプが上記2つのどちらかである場合のみ動作する。

4. **オーバーレイレイヤー（Overlay）**:
   - 責務: 個々のデータ点を重ね描きする。
   - このレイヤーのルールは極めてシンプルである。「`scatter_overlay`オプションがONか？」**のみ**を判定し、ONであれば、**下層のレイヤーで何が描かれたかを一切問わず、常に`dodge=False`で**点をプロットする。

### 7.3. 新アーキテクチャがもたらす堅牢性

- **責務の分離**: 「何を描くか」と「どう配置するか」が完全に分離された。重ね描きの`dodge=False`という重要なルールは、オーバーレイレイヤーの責務として一箇所に集約され、他のレイヤーの変更から影響を受けなくなった。
- **拡張性の向上**: 新しいグラフタイプ（例: `heatmap`）を追加する場合、ベースレイヤーの担当リストに`heatmap`を追加するだけでよく、他のレイヤーのコードに触る必要がなくなった。
- **情報共有の仕組み**: 各レイヤーは互いに直接通信しない。`matplotlib`の`Axes`オブジェクト（共通のキャンバス）の状態を読み書きすることで、サブグループの位置情報などを間接的かつ正確に共有する。
- **ファセットへの対応**: このレイヤー化された描画プロセス全体を、ファセットの各サブプロット（`ax`）に対して`for`ループで個別に適用する「分割統治」戦略により、複雑なファセットグラフも堅牢に描画できる。

このアーキテクチャへの移行は、Calciteの描画エンジンを、場当たり的な修正の積み重ねから、将来の拡張にも耐えうる、真に堅牢でメンテナンス性の高い構造へと進化させるための重要なブレークスルーである。

## 8. 重ね描きにおける`dodge`問題の根本解決と意図解釈の高度化 (2025/08/28)

### 8.1. 課題：特定条件下で再発する「二重dodge」問題

`dodge`ロジックの修正後も、特定のデータ構造において重ね描き（`stripplot`）の位置がずれる問題が再発した。特に、ユーザーからのフィードバックにより、**X軸に指定した列とサブグループ（`hue`）に指定した列が同一である場合**に問題が顕在化することが判明した。

- **成功ケース**: X軸と`hue`が異なる列の場合（例: X=`Ab_conc`, `hue`=`group`）。ベースプロットが`hue`によって分割（dodge）され、重ね描きも正しく追従する。
- **失敗ケース**: X軸と`hue`が同じ列の場合（例: X=`group`, `hue`=`group`）。ユーザーの意図はカテゴリごとの**色分け**であり、`seaborn`のベースプロットもその意図を汲んで位置分割（dodge）を行わない。しかし、重ね描き側のロジックが「`hue`が指定されている」という事実のみに基づき`dodge=True`と判断してしまい、不要な位置計算を行うことでズレが生じていた。

### 8.2. 解決策：ユーザーの「意図」を解釈するロジックの導入

この問題を根本的に解決するため、重ね描きレイヤーの`dodge`実行条件を、単なる`hue`の有無から、**「`hue`が指定されており、かつ、それがX軸の列と異なるか」**という、より高度な条件へと修正した。

このロジックは、ユーザーの操作の意図をより正確に解釈するものである。

- `X`と`hue`が**同じ** → 意図は「色分け」→ `dodge`しない
- `X`と`hue`が**異なる** → 意図は「分割」→ `dodge`する

この修正により、`graph_manager`はベースプロットと完全に一貫した挙動をとり、あらゆるデータと設定の組み合わせにおいて、重ね描きが常に正しい位置に描画される堅牢性を実現した。これは、長年の課題であった`dodge`問題の最終的な解決となる。
